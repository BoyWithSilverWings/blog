---
title: 'Scopes and Closures'
date: '2019-02-15T22:12:03.284Z'
tags:
  ['scopes', 'closure', 'javascript', 'types', 'must learn javascript concepts']
published: false
---

import CodeViewer from '../components/code-viewer';
import JSLive from 'react-js-live';

This is part of a series where I try to explain through each of [33 JS Concepts](https://github.com/leonardomso/33-js-concepts).

This part corresponds to the Scopes and Closures.

## Scope

### What is scope of a variable?

Scope in programming stands for visibility and usage. For reasons considered obvious (but ones that we will still discuss), we cannot allow all variables in our program to be global. Scope is what limits the variable to used across certain limits and boundaries.

### Why scope variables?

#### 1. Collision Avoidance

We cannot declare two variables with the same name. This would throw a reference error.

<CodeViewer
  code={`
var length = 1;
// some operation going on, after sometime you think
var length = 1; // Nope!`}
/>

You know how this can be problematic.

But we absolutely should not use the same variables for different purposes. It there are no boundaries, it becomes confusing for people who read your code. This becomes more problematic when there are lots of people on the team. How does anyone know if someone else has already declared the variable?

Clear boundaries on where you can access a variable makes it easier for all developers in the project to avoid conflcits.

#### 2. Garbage Collection

Say you have lots of API calls going on and data coming from all sides. What if all the results are retained in the memory all the time. Do we want that?

When we complete the usage of a variable, we want the variable and the data it is holding to be garbage collected. In dynamic languages, we expect this to happen automatically. But if we don't have any boundaries on where the variable can be accessed it would happen that the compiler does not have any hint on when to collect the garbage. Except may be at the end.

Having clear boundaries on where variables can be accessed can tell the compiler, that at the end of this scope it is safe to garbage collect these variables.

JavaScript has two kinds of scope:

1. Block Scope
2. Function Scope

We will talk about function scope first.

### Function Scope

Function Scope means that any variable declared would be available inside the function. This has existed and was widely used from olden times in JavaScript.

<CodeViewer
  code={`
function action() {
  var a = 2;
  ... // actions
  // a can be accessed anywhere in this function.
}
  `}
/>

#### Hoisting

Wherever you declare a variable, JavaScript would proceed to hoist these upto the top of their scope. But let us be semantically correct here. JavaScript does not move the variables physically all your code remains the same. The compiler just picks the variables in it's current scope and declares them in compiler time with the value `undefined`.

<JSLive
  snippets={{
    html: ``,
    css: ``,
    js: `
function init() {
  console.log(a);
  var a = 1;
}
 
init();
    `,
  }}
/>

This is how you can access a variable before declaration and get `undefined` as an answer.

You don't have to be afraid of hoisting. In fact hositing is what helps you when declaring functions in whichever order you want. Since the compiler would hoist it to the top anyway, it does not matter which order you declare it in. But with variables declared with `var`, it is important to write short precise functions.

Also, note that only declarations are hoisted, they would not take any value if used before initialisation.

### Block Scope

This is widely used from ES6. Block refers to a `{}` in a program.

Block Scope means that the variables defined inside a `{}` can only be used inside it. Variables can be put in block scope by declaring them with `let` or `const`.

Note that functions also form block scope.

<CodeViewer
  code={`
function action(limit) {
  const a = 10;   // a can only be used inside this function
  if(a < limit) {
    const b = a + 2;  // b can only be used inside this if block, a can also be used here as this block is inside the execution context of a's block
    return b;
  }
}
  `}
/>

#### Hoisting

Does hoisting happen in Block Scope? Yes. But if we try and use a variable before it's actual declaration, we get a `ReferenceError`.

_That does not make any sense. If they are hoisted, shouldn't they be undefined?_

To get ahead of this question, JavaScript spec defines something known as a Temperal Dead Zone (TDZ). This is the difference of when it is memory (remember: Hoisting is just compiler putting variable declarations in memory) and it's actual declaration in code. When a block scoped variable in TDZ is accessed, it throws a `ReferenceError`.

## Closures

## Execution Context
